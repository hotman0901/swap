{"version":3,"sources":["App.js","reportWebVitals.js","index.js"],"names":["App","iconSize","grid_width","grid_height","active_icon","playAreaOffset","grid","getRandomElement","Math","floor","random","onBlockDown","e","block","$","currentTarget","addClass","onBlockMove","preventDefault","cursor_x","pageX","cursor_y","pageY","originalEvent","touches","pointer_x","pointer_y","passiveLocation","px_x","px_y","left","top","x","y","grid_x_count","grid_y_count","getGridLocation","swapLocation","attr","css","onBlockUp","removeClass","checkBlocks","clear","activeX","activeY","passiveX","passiveY","tmp","active","passive","useEffect","initGrid","w","width","height","min","fontSize","offset","iconDiv","append","hide","render","on","className","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.6d97ac93.chunk.js","sourcesContent":["import \"./reset.css\";\nimport \"./puzzle.css\";\nimport * as $ from \"jquery\";\nimport React, { useEffect } from \"react\";\nimport wait from \"waait\";\n\n// 排序轉珠位置\n// grid[0][0], grid[1][0], grid[2][0], grid[3][0], grid[4][0], grid[5][0]\n// grid[0][1], grid[1][1], grid[2][1], grid[3][1], grid[4][1], grid[5][1]\n// grid[0][2], grid[1][2], grid[2][2], grid[3][2], grid[4][2], grid[5][2]\n// grid[0][3], grid[1][3], grid[2][3], grid[3][3], grid[4][3], grid[5][3]\n// grid[0][4], grid[1][4], grid[2][4], grid[3][4], grid[4][4], grid[5][4]\n// grid[0][5], grid[1][5], grid[2][5], grid[3][5], grid[4][5], grid[5][5]\n// const container = null;\nfunction App() {\n  const grid_x_count = 6;\n  const grid_y_count = 5;\n\n  // 總共有幾種元素\n  const numElements = 6;\n\n  let iconSize, // icon 長寬比\n    grid_width, // 棋盤寬度\n    grid_height, // 棋盤高度\n    active_icon, // 有按下的時候的物件\n    playAreaOffset,\n    lastCombo = 0,\n    disableMove = false;\n\n  let grid = []; // 存放全部轉珠顏色的陣列數字（有移動的話也要跟著更新 grid）\n\n  useEffect(() => {\n    // container = $(\".container\");\n    initGrid();\n    render();\n    bindEvent();\n    return () => {};\n  }, []);\n\n  // 建立轉隨機陣列\n  function initGrid() {\n    // 放置二維陣列 （屬性陣列用）\n    for (let x = 0; x < grid_x_count; x++) {\n      grid[x] = [];\n      for (let y = 0; y < grid_y_count; y++) {\n        // 隨機數字 1-6\n        grid[x][y] = getRandomElement();\n      }\n    }\n  }\n\n  // 隨機數字\n  function getRandomElement() {\n    return Math.floor(Math.random() * numElements);\n  }\n\n  function render() {\n    // 先算出畫面寬度可以放的珠珠大小\n    // 畫面寬度除以要x幾顆\n    let w = $(\"body\").width() / grid_x_count;\n    // 畫面高度除以要y幾顆\n    let y = $(\"body\").height() / grid_y_count;\n    // 兩者取最小當作 iconSize\n    iconSize = Math.floor(Math.min(w, y));\n\n    // 算出轉珠區域\n    // 轉換成實際寬高 px\n    grid_width = iconSize * grid_x_count;\n    grid_height = iconSize * grid_y_count;\n\n    // 轉珠區域給上長寬\n    $(\".play-area\").css({\n      width: grid_width,\n      height: grid_height,\n      fontSize: iconSize,\n    });\n\n    // 取出轉珠框框距離瀏覽器 top、left 位置 用來絕對定位每一個珠珠用\n    playAreaOffset = $(\".play-area\").offset();\n    const { left, top } = playAreaOffset;\n    // 將二維陣列的轉珠放上去\n    for (let x = 0; x < grid_x_count; x++) {\n      for (let y = 0; y < grid_y_count; y++) {\n        // 建立轉珠 icon 用 div\n        // data-x data-y 用來記住原本的座標位置\n        const iconDiv = $(\n          '<div class=\"block\" data-x=\"' + x + '\" data-y=\"' + y + '\"></div>'\n        );\n\n        // 依序放位置\n        iconDiv.css({\n          left: x * iconSize + left, // 第幾個 icon 加上 離瀏覽器左邊位置\n          top: y * iconSize + top,\n          width: iconSize,\n          height: iconSize,\n        });\n\n        // 用來給img\n        iconDiv.addClass(`elem-${grid[x][y]}`);\n        $(\".play-area\").append(iconDiv);\n      }\n    }\n\n    var comboDiv = $(\".combo\");\n    comboDiv\n      .css({\n        fontSize: iconSize * 0.6,\n      })\n      .hide();\n  }\n\n  // 綁定移動\n  function bindEvent() {\n    // 裝置偵測\n    $(\"body\").on(\"mousedown\", \".block\", onBlockDown); // mouse 按下的時候\n    $(\"body\").on(\"mousemove\", onBlockMove); // mouse 拖拉的時候\n    $(\"body\").on(\"mouseup\", onBlockUp);\n    // touch 按下的時候\n    $(\"body\").on(\"touchstart\", \".block\", onBlockDown);\n    $(\"body\").on(\"touchmove\", onBlockMove);\n    $(\"body\").on(\"touchend\", onBlockUp);\n    // pointer 按下的時候\n    $(\"body\").on(\"pointerdown\", \".block\", onBlockDown);\n    $(\"body\").on(\"pointermove\", onBlockMove);\n    $(\"body\").on(\"pointerup\", onBlockUp);\n  }\n\n  // 按下\n  function onBlockDown(e) {\n    // 是否可以移動\n    // if (disableMove) {\n    //   return;\n    // }\n\n    // 增加 css .active 主要是讓他 transition: none 這樣轉動動畫比較正常\n    const block = $(e.currentTarget);\n    block.addClass(\"active\");\n    // 將物件放到全域變數\n    active_icon = block;\n  }\n\n  // 移動\n  function onBlockMove(e) {\n    e.preventDefault();\n    // 如果沒有按下給予的物件就不給移動\n    if (!active_icon) {\n      return;\n    }\n\n    // 目前滑鼠移動\n    let cursor_x = e.pageX;\n    let cursor_y = e.pageY;\n\n    // 取不到值應該是移動端\n    if (!cursor_x && !cursor_y) {\n      if (e.originalEvent.touches) {\n        // touch\n        cursor_x = e.originalEvent.touches[0].pageX;\n        cursor_y = e.originalEvent.touches[0].pageY;\n      } else {\n        // pointer\n        cursor_x = e.originalEvent.pageX;\n        cursor_y = e.originalEvent.pageY;\n      }\n    }\n\n    // 會遇到圖片位置跑走必須偏移他\n    const pointer_x = cursor_x - iconSize / 2;\n    const pointer_y = cursor_y - iconSize / 2;\n\n    // 利用目前滑鼠位置取出經過該元素的二維陣列 index\n    const passiveLocation = getGridLocation(cursor_x, cursor_y);\n\n    swapLocation(\n      active_icon.attr(\"data-x\"),\n      active_icon.attr(\"data-y\"),\n      passiveLocation.x,\n      passiveLocation.y\n    );\n\n    active_icon.css({\n      left: pointer_x,\n      top: pointer_y,\n    });\n  }\n\n  function onBlockUp(e) {\n    if (!active_icon) {\n      // 這裡會有一個 bug，下面 null 掉 jquery 會失效 時間差造成\n      return;\n    }\n\n    const { left, top } = playAreaOffset;\n    // 固定回位置\n    active_icon.removeClass(\"active\").css({\n      left: active_icon.attr(\"data-x\") * iconSize + left,\n      top: active_icon.attr(\"data-y\") * iconSize + top,\n    });\n    // 清除\n    active_icon = null;\n\n    // combo 歸零\n    lastCombo = 0;\n\n    // 不可移動\n    disableMove = true;\n\n    // 判斷三顆以上需要消除\n    checkBlocks();\n  }\n\n  function checkBlocks() {\n    let clear = [];\n    // 計算有無 clear 的轉珠\n    let countClear = 0;\n    for (let x = 0; x < grid_x_count; x++) {\n      clear[x] = [];\n    }\n\n    // 依序遍歷\n    for (let x = 0; x < grid_x_count; x++) {\n      for (let y = 0; y < grid_y_count; y++) {\n        // grid[[], [], [], [], []]\n        // 0: (5) [2, 1, 4, 1, 4]\n        // 1: (5) [3, 4, 0, 3, 1]\n        // 2: (5) [4, 4, 3, 5, 4]\n        // 3: (5) [2, 3, 5, 1, 1]\n        // 4: (5) [2, 2, 1, 1, 0]\n        // 5: (5) [4, 3, 2, 4, 4]\n\n        // 實際第一排為 5 * 6\n        // grid[0][0], grid[1][0], grid[2][0], grid[3][0], grid[4][0], grid[5][0]\n        // grid[0][1], grid[1][1], grid[2][1], grid[3][1], grid[4][1], grid[5][1]\n        // grid[0][2], grid[1][2], grid[2][2], grid[3][2], grid[4][2], grid[5][2]\n        // grid[0][3], grid[1][3], grid[2][3], grid[3][3], grid[4][3], grid[5][3]\n        // grid[0][4], grid[1][4], grid[2][4], grid[3][4], grid[4][4], grid[5][4]\n\n        // 因為3顆就要消除\n        //\n        // 消除是直條，所以我們要遍歷  5 - 2 = 3 次\n        // (grid[0][0], grid[0][1], grid[0][2]) -> (grid[0][1], grid[0][2], grid[0][3]) -> (grid[0][2], grid[0][3], grid[0][4])\n        // 所以是要這樣判斷\n        if (\n          y < grid_y_count - 2 &&\n          grid[x][y] === grid[x][y + 1] &&\n          grid[x][y] === grid[x][y + 2]\n        ) {\n          countClear++;\n          // 記錄要消除的 array index\n          clear[x][y] = grid[x][y] + \" blank\";\n          clear[x][y + 1] = grid[x][y] + \" blank\";\n          clear[x][y + 2] = grid[x][y] + \" blank\";\n          // 給要消除的轉珠加上 css\n          $(\"[data-x=\" + x + \"][data-y=\" + y + \"]\").addClass(\"blank\");\n          $(\"[data-x=\" + x + \"][data-y=\" + (y + 1) + \"]\").addClass(\"blank\");\n          $(\"[data-x=\" + x + \"][data-y=\" + (y + 2) + \"]\").addClass(\"blank\");\n        }\n\n        // x 軸同 y 軸判斷\n\n        // 實際第一排為 5 * 6\n        // grid[0][0], grid[1][0], grid[2][0], grid[3][0], grid[4][0], grid[5][0]\n        // grid[0][1], grid[1][1], grid[2][1], grid[3][1], grid[4][1], grid[5][1]\n        // grid[0][2], grid[1][2], grid[2][2], grid[3][2], grid[4][2], grid[5][2]\n        // grid[0][3], grid[1][3], grid[2][3], grid[3][3], grid[4][3], grid[5][3]\n        // grid[0][4], grid[1][4], grid[2][4], grid[3][4], grid[4][4], grid[5][4]\n        // x 軸相同\n        if (\n          x < grid_x_count - 2 &&\n          grid[x][y] === grid[x + 1][y] &&\n          grid[x][y] === grid[x + 2][y]\n        ) {\n          countClear++;\n          // 記錄要消除的 array index\n          clear[x][y] = grid[x][y] + \" blank\";\n          clear[x + 1][y] = grid[x][y] + \" blank\";\n          clear[x + 2][y] = grid[x][y] + \" blank\";\n          // 給要消除的轉珠加上 css blank\n          $(\"[data-x=\" + x + \"][data-y=\" + y + \"]\").addClass(\"blank\");\n          $(\"[data-x=\" + (x + 1) + \"][data-y=\" + y + \"]\").addClass(\"blank\");\n          $(\"[data-x=\" + (x + 2) + \"][data-y=\" + y + \"]\").addClass(\"blank\");\n        }\n\n        // 代表沒有消除的地方才會 clear 會取不到值\n        if (!clear[x][y]) {\n          clear[x][y] = grid[x][y];\n        }\n      }\n    }\n\n    grid = clear;\n\n    // 代表有要消除的連線\n    // if (countClear > 0) {\n    //   clearSection(false);\n    // } else {\n    //   // 隱影 combo\n    //   $(\".combo\").hide();\n    //   // 才可以執行 move\n    //   disableMove = false;\n    // }\n  }\n\n  // 清除元素\n  async function clearSection(delay) {\n    if (delay) {\n      // 連續\n      lastCombo++;\n      // 連續超過兩次 就顯示 combo\n      if (lastCombo > 2) {\n        $(\".combo\")\n          .text(\"Combo \" + lastCombo + \"!\")\n          .show();\n      }\n      await wait(320);\n      // 移除屬性\n      $(\".block.flash\").attr(\"class\", \"block\");\n    }\n\n    await wait((delay = delay ? 100 : 0));\n\n    const exist = $(\".block.blank\").length > 0;\n    if (exist) {\n      // 需要利用演算法\n      // 類似使用algorithms-number-of-islands作法\n      // https://javascript.plainenglish.io/javascript-algorithms-number-of-islands-leetcode-6eff200bdf1\n      // 因為使用 algorithms-number-of-islands 必須知道我要消除的是什麼顏色的，所以我們取出 .block.blank 第一個元素重複去找\n      const block = $($(\".block.blank\")[0]);\n\n      // 取得 x-y 座標 然後再從  grid 取得是什麼顏色\n      const x = parseInt(block.attr(\"data-x\"));\n      const y = parseInt(block.attr(\"data-y\"));\n      findSection(x, y, grid[x][y], true);\n    } else {\n      // 如果沒有了\n      dropBlock();\n    }\n  }\n\n  // 將目前畫面的空白的慢慢 swap 位置\n  async function dropBlock() {\n    var dropped = false;\n    // step1. 先把有移除掉的空白往下填滿\n    for (let x = 0; x < grid_x_count; x++) {\n      // grid[0][0], grid[1][0], grid[2][0], grid[3][0], grid[4][0], grid[5][0]\n      // grid[0][1], grid[1][1], grid[2][1], grid[3][1], grid[4][1], grid[5][1]\n      // grid[0][2], grid[1][2], grid[2][2], grid[3][2], grid[4][2], grid[5][2]\n      // grid[0][3], grid[1][3], grid[2][3], grid[3][3], grid[4][3], grid[5][3]\n      // grid[0][4], grid[1][4], grid[2][4], grid[3][4], grid[4][4], grid[5][4]\n      // 要從最下面開始換才會有下墜感\n      for (let y = grid_y_count; y >= 0; y--) {\n        //  從底部開始\n        if (grid[x][y] === \"blank\" && y > 0 && grid[x][y - 1] !== \"blank\") {\n          // 上下調換\n          swapLocation(x, y, x, y - 1);\n          dropped = true;\n        }\n      }\n    }\n    if (dropped) {\n      // 往下降一格後需要 重新 loop 看還有沒有空白\n      await wait(20);\n      dropBlock();\n    } else {\n      // 空白已經都留在最上面，這時候需要將空白亂數填入\n      await wait(20);\n      fillBlock();\n    }\n  }\n\n  // 隨機填入\n  async function fillBlock() {\n    // 先從最上面補，人然後再往下\n    // grid[0][0], grid[1][0], grid[2][0], grid[3][0], grid[4][0], grid[5][0]\n    // grid[0][1], grid[1][1], grid[2][1], grid[3][1], grid[4][1], grid[5][1]\n    // grid[0][2], grid[1][2], grid[2][2], grid[3][2], grid[4][2], grid[5][2]\n    // grid[0][3], grid[1][3], grid[2][3], grid[3][3], grid[4][3], grid[5][3]\n    // grid[0][4], grid[1][4], grid[2][4], grid[3][4], grid[4][4], grid[5][4]\n    let fill = false;\n    // 先看有無空白的\n    for (let x = 0; x < grid_x_count; x++) {\n      const isBlank = grid[x][0] === \"blank\";\n      if (isBlank) {\n        // 隨機字\n        const random = getRandomElement();\n        grid[x][0] = random;\n        // 將 icon 塞入\n        // 將 icon 先從最上面 超出地方進來\n        $(\"[data-x=\" + x + \"][data-y=0]\")\n          .css(\"top\", -iconSize + playAreaOffset.top)\n          .addClass(\"elem-\" + random);\n        fill = true;\n      }\n    }\n\n    // 如果有 blank 再重新執行 dropBlock\n    if (fill) {\n      await wait(80);\n      $(\"[data-y=0]\").css(\"top\", playAreaOffset.top);\n      // 再重新執行 因為我們是從最上面開始補\n      dropBlock();\n    } else {\n      // 空白補充完畢後重新執行，因為有可能新的下來會有3個一樣的\n      checkBlocks();\n    }\n  }\n\n  // 搜尋同顏色鄰兵加上屬性\n  // gridItem = 數字 + blank\n  function findSection(x, y, gridItem, next) {\n    // 有問題的\n    if (\n      x < 0 ||\n      x >= grid_x_count ||\n      y < 0 ||\n      y >= grid_y_count ||\n      grid[x][y] !== gridItem\n    ) {\n      return;\n    }\n\n    // selector 該物件位置的 div\n    const elem = $(\"[data-x=\" + x + \"][data-y=\" + y + \"]\");\n\n    // 如果該物件有我們剛剛加的 blank 屬性，就需要找自己臨兵位置\n    if (elem.hasClass(\"blank\")) {\n      grid[x][y] = \"blank\"; // 原本是 數字 + blank\n      elem.removeClass(\"blank\").addClass(\"flash\"); // 移除掉且增加閃爍屬性\n      // 找自己臨兵位置，再重複 call 一次\n      findSection(x, y + 1, gridItem); // 上\n      findSection(x, y - 1, gridItem); // 下\n      findSection(x - 1, y, gridItem); // 左\n      findSection(x + 1, y, gridItem); // 右\n    }\n\n    // 繼續接著找還有無可以消除的3個以上的\n    if (next) {\n      clearSection(true);\n    }\n  }\n\n  // 交換位置\n  // 目前元素的位置與經過的元素位置交換\n  function swapLocation(activeX, activeY, passiveX, passiveY) {\n    // 位置都依樣就不需要\n    if (activeX === passiveX && activeY === passiveY) {\n      return;\n    }\n\n    // 元素\n    // 0: 藍色\n    // 1: 紅色\n    // 2: 綠色\n    // 3: 金色\n    // 4: 紫色\n    // 5: 粉色\n\n    // 原本的顏色\n    const tmp = grid[activeX][activeY];\n    // 交換位置\n    // 原本位置塞入新的位置\n    grid[activeX][activeY] = grid[passiveX][passiveY];\n    // 新的位置塞入移動原本的位置\n    grid[passiveX][passiveY] = tmp;\n\n    // 交換 data-x data-y\n    var active = $(\"[data-x=\" + activeX + \"][data-y=\" + activeY + \"]\");\n    var passive = $(\"[data-x=\" + passiveX + \"][data-y=\" + passiveY + \"]\");\n\n    active.attr(\"data-x\", passiveX).attr(\"data-y\", passiveY);\n    passive.attr(\"data-x\", activeX).attr(\"data-y\", activeY);\n\n    // 被換移到舊的\n    passive.css({\n      left: activeX * iconSize + playAreaOffset.left,\n      top: activeY * iconSize + playAreaOffset.top,\n    });\n\n    // if(grid[passiveX][passiveY] == 'blank') {\n    // 會有殘影\n    active.css({\n      left: passiveX * iconSize + playAreaOffset.left,\n      top: passiveY * iconSize + playAreaOffset.top,\n    });\n    // }\n  }\n\n  // 參數給 xy 座標，計算出在第幾行第幾列\n  function getGridLocation(px_x, px_y) {\n    const { left, top } = playAreaOffset;\n    let x = px_x - left;\n    let y = px_y - top;\n\n    // 先用 px 位置 轉成第幾個\n    x = Math.floor(x / iconSize);\n    y = Math.floor(y / iconSize);\n\n    if (x >= grid_x_count) {\n      x = grid_x_count - 1;\n    }\n\n    if (x < 0) {\n      x = 0;\n    }\n\n    if (y >= grid_y_count) {\n      y = grid_y_count - 1;\n    }\n\n    if (y < 0) {\n      y = 0;\n    }\n\n    return { x, y };\n  }\n\n  return (\n    <div className=\"app\">\n      <div className=\"container\">\n        {/* 預留 */}\n        {/* <div className=\"display-area\" /> */}\n        {/* 轉珠 */}\n        <div className=\"play-area\" />\n        <div className=\"combo\" />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}