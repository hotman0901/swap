{"version":3,"sources":["App.js","reportWebVitals.js","index.js"],"names":["App","iconSize","grid_width","grid_height","active_icon","playAreaOffset","grid","getRandomElement","Math","floor","random","onBlockDown","e","block","$","currentTarget","addClass","onBlockMove","preventDefault","cursor_x","pageX","cursor_y","pageY","originalEvent","touches","pointer_x","pointer_y","passiveLocation","px_x","px_y","left","top","x","y","grid_x_count","grid_y_count","getGridLocation","activeX","activeY","passiveX","passiveY","tmp","active","passive","attr","css","swapLocation","onBlockUp","removeClass","useEffect","initGrid","w","width","height","min","fontSize","offset","iconDiv","append","render","on","className","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.559d5b92.chunk.js","sourcesContent":["import \"./reset.css\";\nimport \"./puzzle.css\";\nimport * as $ from \"jquery\";\nimport React, { useEffect } from \"react\";\n\n// 排序轉珠位置\n// grid[0][0], grid[1][0], grid[2][0], grid[3][0], grid[4][0], grid[5][0]\n// grid[0][1], grid[1][1], grid[2][1], grid[3][1], grid[4][1], grid[5][1]\n// grid[0][2], grid[1][2], grid[2][2], grid[3][2], grid[4][2], grid[5][2]\n// grid[0][3], grid[1][3], grid[2][3], grid[3][3], grid[4][3], grid[5][3]\n// grid[0][4], grid[1][4], grid[2][4], grid[3][4], grid[4][4], grid[5][4]\n// grid[0][5], grid[1][5], grid[2][5], grid[3][5], grid[4][5], grid[5][5]\n// const container = null;\nfunction App() {\n  const grid_x_count = 6;\n  const grid_y_count = 5;\n\n  // 總共有幾種元素\n  const numElements = 6;\n\n  let iconSize, // icon 長寬比\n    grid_width, // 棋盤寬度\n    grid_height, // 棋盤高度\n    active_icon, // 有按下的時候的物件\n    playAreaOffset;\n\n  let grid = []; // 存放全部轉珠顏色的陣列\n\n  \n  useEffect(() => {\n    // container = $(\".container\");\n    initGrid();\n    render();\n    bindEvent();\n    return () => {};\n  }, []);\n\n  // 建立轉隨機陣列\n  function initGrid() {\n    // 放置二維陣列 （屬性陣列用）\n    for (let x = 0; x < grid_x_count; x++) {\n      grid[x] = [];\n      for (let y = 0; y < grid_y_count; y++) {\n        // 隨機數字 1-6\n        grid[x][y] = getRandomElement();\n      }\n    }\n  }\n\n  // 隨機數字\n  function getRandomElement() {\n    return Math.floor(Math.random() * numElements);\n  }\n\n  function render() {\n    // 先算出畫面寬度可以放的珠珠大小\n    // 畫面寬度除以要x幾顆\n    let w = $(\"body\").width() / grid_x_count;\n    // 畫面高度除以要y幾顆\n    let y = $(\"body\").height() / (grid_y_count);\n    // 兩者取最小當作 iconSize\n    iconSize = Math.floor(Math.min(w, y));\n\n    // 算出轉珠區域\n    // 轉換成實際寬高 px\n    grid_width = iconSize * grid_x_count;\n    grid_height = iconSize * grid_y_count;\n\n    // 轉珠區域給上長寬\n    $(\".play-area\").css({\n      width: grid_width,\n      height: grid_height,\n      fontSize: iconSize,\n    });\n\n    // 取出轉珠框框距離瀏覽器 top、left 位置 用來絕對定位每一個珠珠用\n    playAreaOffset = $(\".play-area\").offset();\n    const { left, top } = playAreaOffset;\n    // 將二維陣列的轉珠放上去\n    for (let x = 0; x < grid_x_count; x++) {\n      for (let y = 0; y < grid_y_count; y++) {\n        // 建立轉珠 icon 用 div\n        // data-x data-y 用來記住原本的座標位置\n        const iconDiv = $(\n          '<div class=\"block\" data-x=\"' + x + '\" data-y=\"' + y + '\"></div>'\n        );\n\n        // 依序放位置\n        iconDiv.css({\n          left: x * iconSize + left, // 第幾個 icon 加上 離瀏覽器左邊位置\n          top: y * iconSize + top,\n          width: iconSize,\n          height: iconSize,\n        });\n\n        // 用來給img\n        iconDiv.addClass(`elem-${grid[x][y]}`);\n        $(\".play-area\").append(iconDiv);\n      }\n    }\n  }\n\n  // 綁定移動\n  function bindEvent() {\n    // 裝置偵測\n    $(\"body\").on(\"mousedown\", \".block\", onBlockDown); // mouse 按下的時候\n    $(\"body\").on(\"mousemove\", onBlockMove); // mouse 拖拉的時候\n    $(\"body\").on(\"mouseup\", onBlockUp);\n    // touch 按下的時候\n    $(\"body\").on(\"touchstart\", \".block\", onBlockDown);\n    $(\"body\").on(\"touchmove\", onBlockMove);\n    $(\"body\").on(\"touchend\", onBlockUp);\n    // pointer 按下的時候\n    $(\"body\").on(\"pointerdown\", \".block\", onBlockDown);\n    $(\"body\").on(\"pointermove\", onBlockMove);\n    $(\"body\").on(\"pointerup\", onBlockUp);\n  }\n\n  // 按下\n  function onBlockDown(e) {\n    // 增加 css .active 主要是讓他 transition: none 這樣轉動動畫比較正常\n    const block = $(e.currentTarget);\n    block.addClass(\"active\");\n    // 將物件放到全域變數\n    active_icon = block;\n  }\n\n  // 移動\n  function onBlockMove(e) {\n    e.preventDefault();\n    // 如果沒有按下給予的物件就不給移動\n    if (!active_icon) {\n      return;\n    }\n\n    // 目前滑鼠移動\n    let cursor_x = e.pageX;\n    let cursor_y = e.pageY;\n\n    // 取不到值應該是移動端\n    if (!cursor_x && !cursor_y) {\n      if (e.originalEvent.touches) {\n        // touch\n        cursor_x = e.originalEvent.touches[0].pageX;\n        cursor_y = e.originalEvent.touches[0].pageY;\n      } else {\n        // pointer\n        cursor_x = e.originalEvent.pageX;\n        cursor_y = e.originalEvent.pageY;\n      }\n    }\n\n    // 會遇到圖片位置跑走必須偏移他\n    const pointer_x = cursor_x - (iconSize / 2);\n    const pointer_y = cursor_y - (iconSize / 2);\n\n    // 利用目前滑鼠位置取出經過該元素的二維陣列 index\n    const passiveLocation = getGridLocation(cursor_x, cursor_y);\n\n    swapLocation(\n      active_icon.attr(\"data-x\"),\n      active_icon.attr(\"data-y\"),\n      passiveLocation.x,\n      passiveLocation.y\n    );\n\n    active_icon.css({\n      left: pointer_x,\n      top: pointer_y,\n    });\n  }\n\n  function onBlockUp(e) {\n    if (!active_icon) {\n      // 這裡會有一個 bug，下面 null 掉 jquery 會失效 時間差造成\n      return;\n    }\n\n    const { left, top } = playAreaOffset;\n    // 固定回位置\n    active_icon.removeClass(\"active\").css({\n      left: active_icon.attr(\"data-x\") * iconSize + left,\n      top: active_icon.attr(\"data-y\") * iconSize + top,\n    });\n    // 清除\n    active_icon = null;\n  }\n\n  // 交換位置\n  // 目前元素的位置與經過的元素位置交換\n  function swapLocation(activeX, activeY, passiveX, passiveY) {\n\t\t// 位置都依樣就不需要\n\t\tif(activeX === passiveX && activeY === passiveY) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// if(!blocksSwapped) {\n\t\t// \tblocksSwapped = true;\n    //   // 倒數\n\t\t// \tstartCountdown();\n\t\t// }\n\t\t\n    // 元素\n    // 0: 藍色\n    // 1: 紅色\n    // 2: 綠色\n    // 3: 金色\n    // 4: 紫色\n    // 5: 粉色 \n    \n    // 原本的顏色\n\t\tvar tmp = grid[activeX][activeY];\n    // 交換位置\n    // 原本位置塞入新的位置\n\t\tgrid[activeX][activeY] = grid[passiveX][passiveY];\n    // 新的位置塞入移動原本的位置\n\t\tgrid[passiveX][passiveY] = tmp;\n\t\t\n    // 交換 data-x data-y \n\t\tvar active = $('[data-x=' + activeX + '][data-y=' + activeY + ']');\n\t\tvar passive = $('[data-x=' + passiveX + '][data-y=' + passiveY + ']');\n\t\t\n\t\tactive.attr('data-x', passiveX).attr('data-y', passiveY);\n\t\tpassive.attr('data-x', activeX).attr('data-y', activeY);\n\n    // 被換移到舊的\n\t\tpassive.css({\n\t\t\tleft: activeX * iconSize + playAreaOffset.left,\n\t\t\ttop: activeY * iconSize + playAreaOffset.top\n\t\t});\n\t\t\n\t\t// if(grid[passiveX][passiveY] == 'blank') {\n    // 會有殘影\n    active.css({\n      left: passiveX * iconSize + playAreaOffset.left,\n      top: passiveY * iconSize + playAreaOffset.top\n    });\n\t\t// }\n\t}\n\n  // 參數給 xy 座標，計算出在第幾行第幾列\n  function getGridLocation(px_x, px_y) {\n    const { left, top } = playAreaOffset;\n    let x = px_x - left;\n    let y = px_y - top;\n\n    // 先用 px 位置 轉成第幾個\n    x = Math.floor(x / iconSize);\n    y = Math.floor(y / iconSize);\n\n    if (x >= grid_x_count) {\n      x = grid_x_count - 1;\n    }\n\n    if (x < 0) {\n      x = 0;\n    }\n\n    if (y >= grid_y_count) {\n      y = grid_y_count - 1;\n    }\n\n    if (y < 0) {\n      y = 0;\n    }\n\n    return { x, y };\n  }\n\n  return (\n    <div className=\"app\">\n      <div className=\"container\">\n        {/* 預留 */}\n        {/* <div className=\"display-area\" /> */}\n        {/* 轉珠 */}\n        <div className=\"play-area\" />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}