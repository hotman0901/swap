{"version":3,"sources":["App.js","reportWebVitals.js","index.js"],"names":["App","iconSize","grid_width","grid_height","active_icon","playAreaOffset","lastCombo","disableMove","grid","getRandomElement","Math","floor","random","onBlockDown","e","preventDefault","$","currentTarget","addClass","onBlockMove","cursor_x","pageX","cursor_y","pageY","originalEvent","touches","newX","newY","pointer_x","pointer_y","passiveLocation","px_x","px_y","left","top","x","y","grid_x_count","grid_y_count","getGridLocation","swapLocation","attr","css","onBlockUp","removeClass","checkBlocks","clear","countClear","clearSection","hide","delay","a","text","show","wait","length","block","parseInt","findSection","dropBlock","dropped","fillBlock","fill","opacity","gridItem","next","elem","hasClass","activeX","activeY","passiveX","passiveY","activePos","passivePos","active","passive","useEffect","initGridItems","w","width","height","min","offset","iconDiv","imgId","append","fontSize","render","on","className","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.2a614988.chunk.js","sourcesContent":["import \"./reset.css\";\nimport \"./puzzle.css\";\nimport * as $ from \"jquery\";\nimport React, { useEffect } from \"react\";\nimport wait from \"waait\";\n\n// 排序轉珠位置\n// grid[0][0], grid[1][0], grid[2][0], grid[3][0], grid[4][0], grid[5][0]\n// grid[0][1], grid[1][1], grid[2][1], grid[3][1], grid[4][1], grid[5][1]\n// grid[0][2], grid[1][2], grid[2][2], grid[3][2], grid[4][2], grid[5][2]\n// grid[0][3], grid[1][3], grid[2][3], grid[3][3], grid[4][3], grid[5][3]\n// grid[0][4], grid[1][4], grid[2][4], grid[3][4], grid[4][4], grid[5][4]\n// grid[0][5], grid[1][5], grid[2][5], grid[3][5], grid[4][5], grid[5][5]\n// const container = null;\nfunction App() {\n  // x y 軸數量\n  const grid_x_count = 6;\n  const grid_y_count = 5;\n\n  // 總共有幾種元素\n  const numElements = 6;\n\n  let iconSize, // icon 長寬比\n    grid_width, // 棋盤寬度\n    grid_height, // 棋盤高度\n    active_icon, // 有按下的時候保存的物件\n    playAreaOffset, // 取出轉珠框框距離瀏覽器 top、left\n    lastCombo = 0, // combo 連續\n    disableMove = false; // 禁止移動\n\n  // 擺放轉珠數字用\n  let grid = []; // 存放全部轉珠顏色的陣列數字（有移動的話也要跟著更新 grid）\n\n  useEffect(() => {\n    initGridItems();\n    render();\n    bindEvent();\n    return () => {};\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // 建立轉隨機陣列\n  function initGridItems() {\n    // 放置二維陣列 （屬性陣列用）\n    for (let x = 0; x < grid_x_count; x++) {\n      grid[x] = [];\n      for (let y = 0; y < grid_y_count; y++) {\n        // 隨機數字 1-6\n        grid[x][y] = getRandomElement();\n      }\n    }\n  }\n\n  // 產生隨機轉珠數字\n  function getRandomElement() {\n    return Math.floor(Math.random() * numElements);\n  }\n\n  // 初始化畫面\n  function render() {\n    // 先算出畫面寬度可以放的珠珠大小\n    // 畫面寬度除以要x幾顆\n    let w = $(\"body\").width() / grid_x_count;\n    // 畫面高度除以要y幾顆\n    let y = $(\"body\").height() / grid_y_count;\n    // 兩者取最小當作 iconSize\n    iconSize = Math.floor(Math.min(w, y));\n\n    // 算出轉珠區域\n    // 轉換成實際寬高 px\n    grid_width = iconSize * grid_x_count;\n    grid_height = iconSize * grid_y_count;\n\n    // 轉珠區域給上長寬\n    $(\".play-area\").css({\n      width: grid_width,\n      height: grid_height,\n    });\n\n    // 取出轉珠框框距離瀏覽器 top、left 位置 用來絕對定位每一個珠珠用\n    playAreaOffset = $(\".play-area\").offset();\n    const { left, top } = playAreaOffset;\n    // 將二維陣列的轉珠放上去\n    for (let x = 0; x < grid_x_count; x++) {\n      for (let y = 0; y < grid_y_count; y++) {\n        // 建立轉珠 icon 用 div\n        // data-x data-y 用來記住原本的座標位置\n        const iconDiv = $(`<div class=\"block\" data-x=\"${x}\" data-y=\"${y}\" />`);\n\n        // 用來給 img background\n        const imgId = `elem-${grid[x][y]}`;\n\n        // 依序放位置\n        // 排序轉珠位置\n        // grid[0][0], grid[1][0], grid[2][0], grid[3][0], grid[4][0], grid[5][0]\n        // grid[0][1], grid[1][1], grid[2][1], grid[3][1], grid[4][1], grid[5][1]\n        // grid[0][2], grid[1][2], grid[2][2], grid[3][2], grid[4][2], grid[5][2]\n        // grid[0][3], grid[1][3], grid[2][3], grid[3][3], grid[4][3], grid[5][3]\n        // grid[0][4], grid[1][4], grid[2][4], grid[3][4], grid[4][4], grid[5][4]\n        // grid[0][5], grid[1][5], grid[2][5], grid[3][5], grid[4][5], grid[5][5]\n        iconDiv\n          .css({\n            left: x * iconSize + left, // 第幾個 icon 加上 離瀏覽器左邊位置\n            top: y * iconSize + top, // 第幾個 icon 加上 離瀏覽器上面位置\n            width: iconSize, // 轉珠尺寸\n            height: iconSize, // 轉珠尺寸\n          })\n          .addClass(imgId);\n\n        $(\".play-area\").append(iconDiv);\n      }\n    }\n\n    // combo div\n    const comboDiv = $(\".combo\");\n    comboDiv\n      .css({\n        fontSize: iconSize * 0.6,\n      })\n      .hide();\n  }\n\n  // 綁定移動\n  function bindEvent() {\n    // 裝置偵測\n    $(\"body\").on(\"mousedown\", \".block\", onBlockDown); // mouse 按下的時候\n    $(\"body\").on(\"mousemove\", onBlockMove); // mouse 拖拉的時候\n    $(\"body\").on(\"mouseup\", onBlockUp);\n    // touch 按下的時候\n    $(\"body\").on(\"touchstart\", \".block\", onBlockDown);\n    $(\"body\").on(\"touchmove\", onBlockMove);\n    $(\"body\").on(\"touchend\", onBlockUp);\n    // pointer 按下的時候\n    $(\"body\").on(\"pointerdown\", \".block\", onBlockDown);\n    $(\"body\").on(\"pointermove\", onBlockMove);\n    $(\"body\").on(\"pointerup\", onBlockUp);\n  }\n\n  // 按下\n  function onBlockDown(e) {\n    e.preventDefault();\n    // 是否可以移動\n    if (disableMove) {\n      return;\n    }\n\n    // 增加 css .active 主要是讓他 transition: none 這樣轉動動畫比較正常\n    // 將物件放到全域變數\n    active_icon = $(e.currentTarget).addClass(\"active\");\n  }\n\n  // 移動\n  function onBlockMove(e) {\n    e.preventDefault();\n    // 如果沒有按下給予的物件就不給移動\n    if (!active_icon) {\n      return;\n    }\n\n    // 目前滑鼠移動\n    const { pageX, pageY } = e;\n    let cursor_x = pageX;\n    let cursor_y = pageY;\n\n    // 取不到值應該是移動端\n    if (!cursor_x && !cursor_y) {\n      const { touches, pageX: newX, pageY: newY } = e.originalEvent;\n      if (touches) {\n        // touch\n        cursor_x = touches[0].pageX;\n        cursor_y = touches[0].pageY;\n      } else {\n        // pointer\n        cursor_x = newX;\n        cursor_y = newY;\n      }\n    }\n\n    // 會遇到圖片位置跑走必須偏移他，道理跟 css transform translate 一樣\n    const pointer_x = cursor_x - iconSize / 2;\n    const pointer_y = cursor_y - iconSize / 2;\n\n    // 利用目前滑鼠位置取出經過該元素的二維陣列 index\n    const passiveLocation = getGridLocation(cursor_x, cursor_y);\n\n    // 交換位置\n    swapLocation(\n      active_icon.attr(\"data-x\"), // 按下的原始位置\n      active_icon.attr(\"data-y\"), // 按下的原始位置\n      passiveLocation.x, // 滑鼠目前位置\n      passiveLocation.y // 滑鼠目前位置\n    );\n\n    // 讓圖片跟著滑鼠走\n    active_icon.css({\n      left: pointer_x,\n      top: pointer_y,\n    });\n  }\n\n  function onBlockUp(e) {\n    if (!active_icon) {\n      // 這裡會有一個 bug，下面 null 掉 jquery 會失效 時間差造成\n      return;\n    }\n\n    const { left, top } = playAreaOffset;\n    // 固定回位置\n    active_icon.removeClass(\"active\").css({\n      left: active_icon.attr(\"data-x\") * iconSize + left,\n      top: active_icon.attr(\"data-y\") * iconSize + top,\n    });\n    // 清除\n    active_icon = null;\n\n    // combo 歸零\n    lastCombo = 0;\n\n    // 不可移動\n    disableMove = true;\n\n    // 判斷三顆以上需要消除\n    checkBlocks();\n  }\n\n  function checkBlocks() {\n    // 需要清除的陣列\n    let clear = [];\n    // 計算有無 clear 的轉珠\n    let countClear = 0;\n\n    // 先產生  clear[[], [], [], [], []]\n    for (let x = 0; x < grid_x_count; x++) {\n      clear[x] = [];\n    }\n\n    // 依序遍歷\n    for (let x = 0; x < grid_x_count; x++) {\n      for (let y = 0; y < grid_y_count; y++) {\n        // grid[[], [], [], [], []]\n        // 0: (5) [2, 1, 4, 1, 4]\n        // 1: (5) [3, 4, 0, 3, 1]\n        // 2: (5) [4, 4, 3, 5, 4]\n        // 3: (5) [2, 3, 5, 1, 1]\n        // 4: (5) [2, 2, 1, 1, 0]\n        // 5: (5) [4, 3, 2, 4, 4]\n\n        // 實際第一排為 5 * 6\n        // grid[0][0], grid[1][0], grid[2][0], grid[3][0], grid[4][0], grid[5][0]\n        // grid[0][1], grid[1][1], grid[2][1], grid[3][1], grid[4][1], grid[5][1]\n        // grid[0][2], grid[1][2], grid[2][2], grid[3][2], grid[4][2], grid[5][2]\n        // grid[0][3], grid[1][3], grid[2][3], grid[3][3], grid[4][3], grid[5][3]\n        // grid[0][4], grid[1][4], grid[2][4], grid[3][4], grid[4][4], grid[5][4]\n\n        // 因為3顆就要消除\n        //\n        // 消除是直條，所以我們要遍歷  5 - 2 = 3 次\n        // (grid[0][0], grid[0][1], grid[0][2]) -> (grid[0][1], grid[0][2], grid[0][3]) -> (grid[0][2], grid[0][3], grid[0][4])\n        // 所以是要這樣判斷\n        if (\n          y < grid_y_count - 2 &&\n          grid[x][y] === grid[x][y + 1] &&\n          grid[x][y] === grid[x][y + 2]\n        ) {\n          countClear++;\n          // 記錄要消除的 array index\n          clear[x][y] = grid[x][y] + \" blank\";\n          clear[x][y + 1] = grid[x][y] + \" blank\";\n          clear[x][y + 2] = grid[x][y] + \" blank\";\n          // 給要消除的轉珠加上 css\n          $(\"[data-x=\" + x + \"][data-y=\" + y + \"]\").addClass(\"blank\");\n          $(\"[data-x=\" + x + \"][data-y=\" + (y + 1) + \"]\").addClass(\"blank\");\n          $(\"[data-x=\" + x + \"][data-y=\" + (y + 2) + \"]\").addClass(\"blank\");\n        }\n\n        // x 軸同 y 軸判斷\n\n        // 實際第一排為 5 * 6\n        // grid[0][0], grid[1][0], grid[2][0], grid[3][0], grid[4][0], grid[5][0]\n        // grid[0][1], grid[1][1], grid[2][1], grid[3][1], grid[4][1], grid[5][1]\n        // grid[0][2], grid[1][2], grid[2][2], grid[3][2], grid[4][2], grid[5][2]\n        // grid[0][3], grid[1][3], grid[2][3], grid[3][3], grid[4][3], grid[5][3]\n        // grid[0][4], grid[1][4], grid[2][4], grid[3][4], grid[4][4], grid[5][4]\n        // x 軸相同\n        if (\n          x < grid_x_count - 2 &&\n          grid[x][y] === grid[x + 1][y] &&\n          grid[x][y] === grid[x + 2][y]\n        ) {\n          countClear++;\n          // 記錄要消除的 array index\n          clear[x][y] = grid[x][y] + \" blank\";\n          clear[x + 1][y] = grid[x][y] + \" blank\";\n          clear[x + 2][y] = grid[x][y] + \" blank\";\n          // 給要消除的轉珠加上 css blank\n          $(\"[data-x=\" + x + \"][data-y=\" + y + \"]\").addClass(\"blank\");\n          $(\"[data-x=\" + (x + 1) + \"][data-y=\" + y + \"]\").addClass(\"blank\");\n          $(\"[data-x=\" + (x + 2) + \"][data-y=\" + y + \"]\").addClass(\"blank\");\n        }\n\n        // 代表沒有消除的地方才會 clear 會取不到值\n        if (!clear[x][y]) {\n          clear[x][y] = grid[x][y];\n        }\n      }\n    }\n\n    grid = clear;\n\n    // 代表有要消除的連線\n    if (countClear > 0) {\n      clearSection(false);\n    } else {\n      // 隱影 combo\n      $(\".combo\").hide();\n      // 才可以執行 move\n      disableMove = false;\n    }\n  }\n\n  // 清除元素\n  async function clearSection(delay) {\n    if (delay) {\n      // 連續\n      lastCombo++;\n      // 連續超過兩次 就顯示 combo\n      if (lastCombo > 2) {\n        $(\".combo\")\n          .text(\"Combo \" + lastCombo + \"!\")\n          .show();\n      }\n      await wait(300);\n      // 移除屬性\n      $(\".block.flash\").attr(\"class\", \"block\");\n    }\n\n    await wait(delay ? 200 : 0);\n\n    const exist = $(\".block.blank\").length > 0;\n    if (exist) {\n      // 需要利用演算法\n      // 類似使用algorithms-number-of-islands作法\n      // https://javascript.plainenglish.io/javascript-algorithms-number-of-islands-leetcode-6eff200bdf1\n      // 因為使用 algorithms-number-of-islands 必須知道我要消除的是什麼顏色的，所以我們取出 .block.blank 第一個元素重複去找\n      const block = $($(\".block.blank\")[0]);\n\n      // 取得 x-y 座標 然後再從  grid 取得是什麼顏色\n      const x = parseInt(block.attr(\"data-x\"));\n      const y = parseInt(block.attr(\"data-y\"));\n      findSection(x, y, grid[x][y], true);\n    } else {\n      // 如果沒有了\n      dropBlock();\n    }\n  }\n\n  // 將目前畫面的空白的慢慢 swap 位置\n  async function dropBlock() {\n    let dropped = false;\n    // step1. 先把有移除掉的空白往下填滿（轉珠下面有空白的話就需要往下交換）\n    for (let x = 0; x < grid_x_count; x++) {\n      // grid[0][0], grid[1][0], grid[2][0], grid[3][0], grid[4][0], grid[5][0]\n      // grid[0][1], grid[1][1], grid[2][1], grid[3][1], grid[4][1], grid[5][1]\n      // grid[0][2], grid[1][2], grid[2][2], grid[3][2], grid[4][2], grid[5][2]\n      // grid[0][3], grid[1][3], grid[2][3], grid[3][3], grid[4][3], grid[5][3]\n      // grid[0][4], grid[1][4], grid[2][4], grid[3][4], grid[4][4], grid[5][4]\n      // 要從最下面開始換才會有下墜感\n      for (let y = grid_y_count; y >= 0; y--) {\n        //  從底部開始\n        if (grid[x][y] === \"blank\" && y > 0 && grid[x][y - 1] !== \"blank\") {\n          // 上下調換\n          swapLocation(x, y, x, y - 1);\n\n          dropped = true;\n        }\n      }\n    }\n    if (dropped) {\n      // 往下降一格後需要 重新不停 loop 直到轉珠下面沒有空白\n      await wait(50);\n      dropBlock();\n    } else {\n      // 空白已經都留在最上面，這時候需要將空白亂數填入\n      await wait(50);\n      fillBlock();\n    }\n  }\n\n  // 隨機填入\n  async function fillBlock() {\n    // grid[0][0], grid[1][0], grid[2][0], grid[3][0], grid[4][0], grid[5][0]\n    // grid[0][1], grid[1][1], grid[2][1], grid[3][1], grid[4][1], grid[5][1]\n    // grid[0][2], grid[1][2], grid[2][2], grid[3][2], grid[4][2], grid[5][2]\n    // grid[0][3], grid[1][3], grid[2][3], grid[3][3], grid[4][3], grid[5][3]\n    // grid[0][4], grid[1][4], grid[2][4], grid[3][4], grid[4][4], grid[5][4]\n    let fill = false;\n    // 先看有無空白的\n    for (let x = 0; x < grid_x_count; x++) {\n      // 先從最上面補，然後再往下掉\n      const isBlank = grid[x][0] === \"blank\";\n      if (isBlank) {\n        // 隨機字\n        const random = getRandomElement();\n        grid[x][0] = random;\n        // 將 icon 塞入\n        // 將 icon 先從最上面 超出地方進來\n        $(\"[data-x=\" + x + \"][data-y=0]\")\n          .css({ top: -iconSize + playAreaOffset.top, opacity: 0 })\n          .addClass(\"elem-\" + random);\n        fill = true;\n      }\n    }\n\n    // 如果有 blank 再重新執行 dropBlock\n    if (fill) {\n      await wait(50);\n      $(\"[data-y=0]\").css({ top: playAreaOffset.top, opacity: 1 });\n      // 再重新執行 因為我們是從最上面開始補\n      dropBlock();\n    } else {\n      // 空白補充完畢後重新執行，因為有可能新的下來會有3個一樣的\n      checkBlocks();\n    }\n  }\n\n  // 搜尋同顏色鄰兵加上屬性\n  // gridItem = 數字 + blank\n  function findSection(x, y, gridItem, next) {\n    // 有問題的\n    if (\n      x < 0 ||\n      x >= grid_x_count ||\n      y < 0 ||\n      y >= grid_y_count ||\n      grid[x][y] !== gridItem\n    ) {\n      return;\n    }\n\n    // selector 該物件位置的 div\n    const elem = $(\"[data-x=\" + x + \"][data-y=\" + y + \"]\");\n\n    // 如果該物件有我們剛剛加的 blank 屬性，就需要找自己臨兵位置\n    if (elem.hasClass(\"blank\")) {\n      grid[x][y] = \"blank\"; // 原本是 數字 + blank\n      elem.removeClass(\"blank\").addClass(\"flash\"); // 移除掉且增加閃爍屬性\n      // 找自己臨兵位置，再重複 call 一次\n      findSection(x, y + 1, gridItem, false); // 上\n      findSection(x, y - 1, gridItem, false); // 下\n      findSection(x - 1, y, gridItem, false); // 左\n      findSection(x + 1, y, gridItem, false); // 右\n    }\n\n    // 繼續接著找還有無可以消除的3個以上的\n    if (next) {\n      clearSection(true);\n    }\n  }\n\n  // 交換位置\n  // 目前元素的位置與經過的元素位置交換\n  function swapLocation(activeX, activeY, passiveX, passiveY) {\n    // 位置都依樣就不需要\n    if (activeX === passiveX && activeY === passiveY) {\n      return;\n    }\n\n    // 元素\n    // 0: 藍色\n    // 1: 紅色\n    // 2: 綠色\n    // 3: 金色\n    // 4: 紫色\n    // 5: 粉色\n\n    // 原本的顏色\n    const activePos = grid[activeX][activeY];\n    // 交換的\n    const passivePos = grid[passiveX][passiveY];\n\n    // step1. 交換 grid 內容\n    // 原本位置塞入新的位置\n    grid[activeX][activeY] = passivePos;\n    // 新的位置塞入移動原本的位置\n    grid[passiveX][passiveY] = activePos;\n\n    // step2. 交換 data-x data-y\n    // 交換 data-x data-y\n    const active = $(\"[data-x=\" + activeX + \"][data-y=\" + activeY + \"]\");\n    const passive = $(\"[data-x=\" + passiveX + \"][data-y=\" + passiveY + \"]\");\n\n    active.attr(\"data-x\", passiveX).attr(\"data-y\", passiveY);\n    passive.attr(\"data-x\", activeX).attr(\"data-y\", activeY);\n\n    // 位置交換被換移到舊的\n    passive.css({\n      left: activeX * iconSize + playAreaOffset.left,\n      top: activeY * iconSize + playAreaOffset.top,\n    });\n\n    active.css({\n      left: passiveX * iconSize + playAreaOffset.left,\n      top: passiveY * iconSize + playAreaOffset.top,\n    });\n  }\n\n  // 參數給 xy 座標，計算出在第幾行第幾列\n  function getGridLocation(px_x, px_y) {\n    const { left, top } = playAreaOffset;\n    let x = px_x - left;\n    let y = px_y - top;\n\n    // 先用 px 位置 轉成第幾個\n    x = Math.floor(x / iconSize);\n    y = Math.floor(y / iconSize);\n\n    if (x >= grid_x_count) {\n      x = grid_x_count - 1;\n    }\n\n    if (x < 0) {\n      x = 0;\n    }\n\n    if (y >= grid_y_count) {\n      y = grid_y_count - 1;\n    }\n\n    if (y < 0) {\n      y = 0;\n    }\n\n    return { x, y };\n  }\n\n  return (\n    <div className=\"app\">\n      <div className=\"container\">\n        {/* 預留 */}\n        {/* <div className=\"display-area\" /> */}\n        {/* 轉珠 */}\n        <div className=\"play-area\" />\n        <div className=\"combo\" />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}